# STEP 16: Transaction Diagnosis (with SAGA Pattern)

## MSA 기반 도메인 분리 설계

서비스 규모가 커짐에 따라 도메인 기반으로 시스템을 분리하여 각각 독립적으로 배포 가능한 형태의 MSA 아키텍처를 구성할 수 있습니다.

- **주문(Order) 서비스**: 주문 생성, 상태 관리
- **결제(Payment) 서비스**: 포인트 차감, 결제 처리
- **재고(Product) 서비스**: 재고 감소 및 복구
- **쿠폰(Coupon) 서비스**: 쿠폰 적용/회수
- **데이터 플랫폼(DataPlatform) 서비스**: 외부 통계 시스템 전송 등

---

## 트랜잭션 분리에 따른 문제 상황

단일 시스템에서는 하나의 트랜잭션 내에서 정합성을 보장할 수 있지만, MSA로 분리되면 다음과 같은 문제가 발생할 수 있습니다:

1. **분산 트랜잭션**: 서로 다른 서비스 간 DB 작업을 하나의 트랜잭션으로 묶을 수 없음
2. **정합성 붕괴**: 중간 실패 발생 시 데이터 상태 불일치
3. **네트워크 지연/실패로 인한 재시도 및 보상 처리 필요**

---

## 해결 전략: SAGA 패턴 적용

**SAGA 패턴**은 각 도메인 서비스가 자체 로컬 트랜잭션을 수행하고, 실패 시 보상 트랜잭션을 실행해 전체 흐름을 조정하는 분산 트랜잭션 처리 전략입니다.

### 적용 시나리오

- 주문 생성 → 주문 생성 이벤트 발행
- 재고 서비스: 주문 생성 시점에 재고 차감
- 결제 서비스: 포인트 차감 → 실패 시 포인트 복구 및 주문 상태 FAIL
- 쿠폰 서비스: 쿠폰 적용 → 실패 시 포인트 + 재고 복구
- 주문 서비스: 결제 없이 5분 경과 시 스케줄러를 통해 주문 취소

### 보상 트랜잭션 흐름 예시

- 주문 생성 → 재고 차감 성공 → 결제 실패 → **재고 복구**
- 주문 생성 → 재고 차감 성공 → 결제 성공 → 쿠폰 적용 실패 → **포인트 복구 + 재고 복구**
- 주문 생성 → 재고 부족 → **주문 취소**
- 주문 생성 → 재고 성공 → 결제 지연(5분 초과) → **주문 취소 스케줄러 실행**

---

## 이벤트 기반 보완

- 이벤트 발행은 `@EventListener` 또는 `@TransactionalEventListener` 활용
- 핵심 트랜잭션 외부에서 이벤트가 처리되므로 핵심 로직에 영향 없음
- 외부 API 실패 시 로그 기록 또는 MQ 기반 재처리 설계

---

## 복원력 확보 전략

- **로그 기록**: 실패 시 `log.error` 로그를 통해 추적 가능
- **DB 이력 테이블**: 실패 이력 저장 → 배치(Batch) 작업으로 재처리
- **MQ 기반 재처리**: Kafka, Redis Stream 등 메시지 큐로 비동기 재시도 가능

---

## 정리

- MSA 구조에서는 트랜잭션 분리가 불가피하며, 이를 보완하기 위해 **SAGA 패턴**을 도입
- 보상 트랜잭션을 설계하여 실패 시 시스템 정합성 유지
- 이벤트 기반 설계로 서비스 간 결합도를 낮추고, 재처리 및 복원력 향상
- **주문 서비스**는 5분 내 결제되지 않으면 스케줄러를 통해 자동으로 주문을 취소함

---
